package exe.ex2;

/**
 * Introduction to Computer Science 2023, Ariel University,
 * Ex2: arrays, static functions and JUnit
 *
 * This class represents a set of functions on a polynom - represented as array of doubles.
 * The array {0.1, 0, -3, 0.2} represents the following polynom: 0.2x^3-3x^2+0.1
 * This is the main Class you should implement (see "add your code here")
 *
 * @author boaz.benmoshe
 */
public class Ex2 {
	/** Epsilon value for numerical computation, it serves as a "close enough" threshold. */
	public static final double EPS = 0.001; // the epsilon to be used for the root approximation.
	/** The zero polynom is represented as an array with a single (0) entry. */
	public static final double[] ZERO = {0};
	/**
	 * Computes the f(x) value of the polynom at x.
	 * @param poly
	 * @param x
	 * @return f(x) - the polynom value at x.
	 */
	public static double f(double[] poly, double x) {
		double ans = 0;
		for(int i=0;i<poly.length;i++) {
			double c = Math.pow(x, i);
			ans +=c*poly[i];
		}
		return ans;
	}
	/** Given a polynom (p), a range [x1,x2] and an epsilon eps. 
	 * This function computes an x value (x1<=x<=x2) for which |p(x)| < eps, 
	 * assuming p(x1)*p(x1) <= 0. 
	 * This function should be implemented recursively.
	 * @param p - the polynom
	 * @param x1 - minimal value of the range
	 * @param x2 - maximal value of the range
	 * @param eps - epsilon (positive small value (often 10^-3, or 10^-6).
	 * @return an x value (x1<=x<=x2) for which |p(x)| < eps.
	 */
	public static double root_rec(double[] p, double x1, double x2, double eps) {
		double f1 = f(p,x1);
		double f2 = f(p,x2);
		double x12 = (x1+x2)/2;
		double f12 = f(p,x12);
		if (f1*f2<=0 && Math.abs(f12)<eps) {return x12;}
		if(f12*f1<=0) {return root_rec(p, x1, x12, eps);}
		else {return root_rec(p, x12, x2, eps);}
	}
	/**
	 * This function computes a polynomial representation from a set of 2D points on the polynom.
	 * The solution is based on: //	http://stackoverflow.com/questions/717762/how-to-calculate-the-vertex-of-a-parabola-given-three-points
	 * Note: this function only works for a set of points containing up to 3 points, else returns null.
	 * @param xx
	 * @param yy
	 * @return an array of doubles representing the coefficients of the polynom.
	 */
	public static double[] PolynomFromPoints(double[] xx, double[] yy) {
		double [] ans = null;
		int lx = xx.length;
		int ly = yy.length;
		if(xx!=null && yy!=null && lx==ly && lx>1 && lx<4) {
		// add you code here

		////////////////////
		}
		return ans;
	}
	/** Two polynoms are equal if and only if the have the same values f(x) for 1+n values of x, 
	 * where n is the max degree (over p1, p2) - up to an epsilon (aka EPS) value.
	 * @param p1 first polynom
	 * @param p2 second polynom
	 * @return true iff p1 represents the same polynom as p2.
	 */
	public static boolean equals(double[] p1, double[] p2) {
		boolean ans = true;
		int n = Math.max(p1.length, p2.length);
		for (int i = 0; i < n+1; i++)
		{
			if (f(p1,n) - f(p2,n) >= EPS)
			{
				ans = false;
			}
		}
		return ans;
	}

	/** 
	 * Computes a String representing the polynom.
	 * For example the array {2,0,3.1,-1.2} will be presented as the following String  "-1.2x^3 +3.1x^2 +2.0"
	 * @param poly the polynom represented as an array of doubles
	 * @return String representing the polynom: 
	 */
	public static String poly(double[] poly) {
		String ans = "";
		if(poly.length==0) {ans="0";}
		else {
			for (int i = poly.length - 1; i >= 0; i--)
			{
				if ((poly[i] != 0))
				{
					if (i == 0)
					{
						ans += poly[i];
					}
					if (i == 1)
					{
						if (poly[i-1] > 0) {
							ans+=poly[i]+"x"+" +";
						}
						else
						{
							ans+=poly[i]+"x"+"";
						}
					}
					else
					{
						if (i != 0)
						{
							if (poly[i-1] > 0) {
								ans+=poly[i]+"x"+"^"+i+" +";	
							}
							else
							{
								ans+=poly[i]+"x"+"^"+i+" ";	
							}
						}
					}
				}
				else
				{
					if ((poly[i] == 0))
					{
						if (i>1)
						{
							ans+="+";
						}
					}
				}
			}
		}
		return ans;
	}
	/**
	 * Given two polynoms (p1,p2), a range [x1,x2] and an epsilon eps. This function computes an x value (x1<=x<=x2)
	 * for which |p1(x) -p2(x)| < eps, assuming (p1(x1)-p2(x1)) * (p1(x2)-p2(x2)) <= 0.
	 * @param p1 - first polynom
	 * @param p2 - second polynom
	 * @param x1 - minimal value of the range
	 * @param x2 - maximal value of the range
	 * @param eps - epsilon (positive small value (often 10^-3, or 10^-6).
	 * @return an x value (x1<=x<=x2) for which |p1(x) - p2(x)| < eps.
	 */
	public static double sameValue(double[] p1, double[] p2, double x1, double x2, double eps) {
		double ans = x1;
		for (double i = x1; i <= x2; i++) {
			if (f(p1, i) - f(p2, i) <= eps) {
				ans = i;
			}
		}
		return ans;
	}
	/**
	 * Given a polynom (p), a range [x1,x2] and an integer with the number (n) of sample points. 
	 * This function computes an approximation of the length of the function between f(x1) and f(x2) 
	 * using n inner sample points and computing the segment-path between them.
	 * assuming x1 < x2. 
	 * This function should be implemented iteratively (none recursive).
	 * @param p - the polynom
	 * @param x1 - minimal value of the range
	 * @param x2 - maximal value of the range
	 * @param numberOfSegments - (A positive integer value (1,2,...).
	 * @return the length approximation of the function between f(x1) and f(x2).
	 */
	public static double length(double[] p, double x1, double x2, int numberOfSegments) {
		double ans = x1;
		// add you code here

		////////////////////
		return ans;
	}
	
	/**
	 * Given two polynoms (p1,p2), a range [x1,x2] and an integer representing the number of Trapezoids between the functions (number of samples in on each polynom). 
	 * This function computes an approximation of the area between the polynoms within the x-range.
	 * The area is computed using Riemann's like integral (https://en.wikipedia.org/wiki/Riemann_integral)
	 * @param p1 - first polynom
	 * @param p2 - second polynom
	 * @param x1 - minimal value of the range
	 * @param x2 - maximal value of the range
	 * @param numberOfTrapezoid - a natural number representing the number of Trapezoids between x1 and x2.
	 * @return the approximated area between the two polynoms within the [x1,x2] range.
	 */
	public static double area(double[] p1,double[]p2, double x1, double x2, int numberOfTrapezoid) {
		double ans = 0;
		// add you code here

		////////////////////
		return ans;
	}
	/**
	 * this is an assistance function to get the coefficients of the polynom
	 * @param s
	 * @return
	 */
	private static double getCoeff(String s) {
		if (s.startsWith("x")) { // checking whether the index starts with coefficient which equals to 1 
			return 1;
		}
		else if (s.startsWith("-x")) { // checking whether the index starts with coefficient which equals to -1 
			return -1;
		}
		else
			return Double.parseDouble(s.substring(0, s.indexOf("x"))); // returning the coeff accordingly to its index
	}
/**
	 * This function computes the array representation of a polynom from a String
	 * representation. Note:given a polynom represented as a double array,  
	 * getPolynomFromString(poly(p)) should return an array equals to p.
	 * 
	 * @param p - a String representing polynom.
	 * @return
	 */
	public static double[] getPolynomFromString(String p) {
		if ((p != null) && (p != "")) { // checking whether the string is null or not
			p = p.replaceAll("-", "+-"); // replacing all the minus signs with plus minus signs
			p = p.replaceAll(" ", ""); // removing all the spaces
			if (p.startsWith("+-")) {
				p = p.substring(1);
			}
			String [] s = p.split("\\+"); // splitting the string from plus
			int size;
			if (p.contains("^")) { // cheking if the polynom is a quadratic degree or more
				size = Integer.parseInt(s[0].substring(s[0].indexOf("^") + 1)) + 1;
			}
			else if (p.contains("x")) { // cheking if the polynom is from the first degree
				size = 2;
			} else { // if the polynom is less than first degree
				size = 1;
			}
			// till now we checked the degree of the polynom in order to determine the length of the answer array;
			double[] ans = new double[size]; // creating an array with the length of the degree of polynom
			double coeff;
			int index;
			for (int i = 0; i < s.length; i++) {
				if (s[i].contains("^")) { // checking whether the polynom contains any power
					index = Integer.parseInt(s[i].substring(s[i].indexOf("^") + 1)); // determining the index of the coeff
					coeff = getCoeff(s[i]); // getting the coeff using the assist func
				} else if (s[i].contains("x")) { // checking whether the polynom contains any power
					index = 1; // determining the coeff index
					coeff = getCoeff(s[i]); // getting the coeff using the assist func
				} else { 
					coeff = Double.parseDouble(s[i]); // if there is now power left of x's then were in the end of the string 
					index = 0; // determining the coeff index
				}
				ans[index] = coeff; // placing the coeff in the array accordingly to its index;
			}
			return ans; //returning the array
		}
		return null;
	}
	/**
	 * This function computes the polynom which is the sum of two polynoms (p1,p2)
	 * @param p1
	 * @param p2
	 * @return
	 */
	public static double[] add(double[] p1, double[] p2) {
		int s = Math.max(p1.length, p2.length);
		double [] ans = new double [s];
		if (p1.length == p2.length)
		{
			for (int i = 0; i < p1.length; i++)
			{
				for (int j = 0; j < p2.length; j++)
				{
					if (i==j)
					{
						ans[i]+=p1[i]+p2[j];
					}
				}
			}
		}
		if (p1.length > p2.length)
		{
			ans = p1;
			for ( int i = 0; i < ans.length; i++)
			{
				for ( int j = 0; j < p2.length; j++)
				{
					if (i==j)
					{
						ans[i]+=p2[j];
					}
				}
			}
		}
		else
		{
			ans = p2;
			for ( int i = 0; i < ans.length; i++)
				{
				for ( int j = 0; j < p1.length; j++)
				{
					if (i==j)
					{
						ans[i]+=p2[j];
					}
				}
			}
		}
	return ans;
	}
	/**
	 * This function computes the polynom which is the multiplication of two polynoms (p1,p2)
	 * @param p1
	 * @param p2
	 * @return
	 */
	public static double[] mul(double[] p1, double[] p2) {
		int c = p1.length + p2.length - 1;
		double [] ans = new double[c]; // creating a new array with the length of the mul of two polynoms
		for (int i = 0; i < p1.length; i++) // running over the first polynom
		{
			for (int j = 0; j < p2.length; j++) // running over the second polynom
			{
				ans[i+j]+=p1[i]*p2[j]; // multiplying each index of the polynoms with the other and **adding them**
			}
		}
		return ans;
	}
	}
	/**
	 * This function computes the derivative polynom:.
	 * @param po
	 * @return
	 */
	public static double[] derivative (double[] po) {
		int c = po.length-1;
		double [] ans = new double[c]; // creating an ans array of the derivation
		for ( int i = po.length-1; i > 0; i--) // loop running over the polynom
		{
		ans[i-1]= po[i]*i; // equation of computing the derivation of the polynom
		}
	return ans; // return the ans array
	}
	/**
	 * This is a second function how to compute the derivative polynom:.
	 * @param po
	 * @return
	 */
	 public static double [] Derivative (double [] po)
		{
			int c = po.length-1;
			double [] ans = new double[c];
			int j = 0;
			for (int i=1; i<po.length; i++)
			{
				ans[j] = po[i] * i;
				j++;
			}
			return ans;
		}
}
